package io.roach.spring.trees.category;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.*;

import org.springframework.util.Assert;

import io.roach.spring.trees.core.AbstractPersistentEntity;
import io.roach.spring.trees.core.Node;
import io.roach.spring.trees.core.NodeVisitor;
import io.roach.spring.trees.product.CategorizedProduct;
import io.roach.spring.trees.product.Product;

/**
 * Domain object representing a hierarchical product category (group of products). A category may contain zero to
 * many sub-categories. All categories with the same parent (e.g same level) must have unique names,
 * guarded by a unique constraint in the ER model.
 * <p/>
 * Categories are used to group products in a product catalog.
 * <p/>
 * The category hierarchy tree is represented in the ER model using the <i>nested set model</i>
 * approach. This approach provides for much more efficient SQL queries by removing the need
 * for recursive selects. Recursion is notoriously hard to model efficiently in a
 * relational model.
 * <p/>
 * Nested set model: Each category node maintains a left and right number representing the nesting of the node.
 * These numbers must be updated when a node is added or removed to the hierarchy. The nesting values are
 * usually managed internally by the Category repository.
 */
@Entity
@Table(name = "category", uniqueConstraints = @UniqueConstraint(columnNames = {"name", "parent_id"}))
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
// For sub-categories, all subordinate attributes stored in one table
@DiscriminatorColumn(
        name = "category_type",
        discriminatorType = DiscriminatorType.STRING,
        length = 32
)
public class Category extends AbstractPersistentEntity<Long>
        implements Comparable<Category>, Node<Category> {
    /**
     * Primary key, surrogate ID generated by unordered_unique_rowid().
     */
    @Id
    @Column(updatable = false, nullable = false)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Name of the category, unique at each tree level.
     */
    @Column(length = 64, nullable = false)
    private String name;

    /**
     * Some high-level category description.
     */
    @Column(length = 255)
    private String description;

    /**
     * Left value for this node in the nested set model.
     */
    @Column(name = "lft", nullable = false)
    private long left;

    /**
     * Right value for this node in the nested set model.
     */
    @Column(name = "rgt", nullable = false)
    private long right;

    /**
     * Parent category, which is null for root categories.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private Category parent;

    /**
     * Set of sub-categories that can be empty.
     */
    @OneToMany(mappedBy = "parent", cascade = {CascadeType.ALL}, orphanRemoval = true)
    @OrderBy("name asc")
    private List<Category> subCategories = new ArrayList<>();

    /**
     * Set of products in this category modeled with an association table.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @JoinTable(
            name = "categorized_product",
            joinColumns = @JoinColumn(name = "category_id")
    )
    private Set<CategorizedProduct> categorizedProducts = new HashSet<>();

    //--------------------------------------------------------
    // Constructors
    //--------------------------------------------------------

    /**
     * Creates a new empty category.
     */
    protected Category() {
    }

    /**
     * Creates a new category with a name.
     *
     * @param name the name, cannot be <code>null</code>
     * @throws IllegalArgumentException if name is <code>null</code>
     */
    public Category(String name) {
        Assert.notNull(name, "name is null");
        this.name = name;
    }

    /**
     * Creates a new sub-category with a name and description.
     *
     * @param parent the parent category, cannot be <code>null</code>
     * @param name the name, cannot be <code>null</code>
     * @throws IllegalArgumentException if parent or name is <code>null</code>
     */
    public Category(Category parent, String name) {
        this(name);
        Assert.notNull(name, "parent is null");
        parent.add(this);
    }

    //--------------------------------------------------------
    // Instance getters/setters
    //--------------------------------------------------------

    @Override
    public int getDescendants() {
        return (int) (right - left - 1) / 2;
    }

    @Override
    public int getLevel() {
        int level = 1;
        Category p = getParent();
        while (p != null) {
            level++;
            p = p.getParent();
        }
        return level;
    }

    @Override
    public Deque<Category> getPath() {
        Deque<Category> s = new ArrayDeque<>();
        s.push(this);
        Category p = getParent();
        while (p != null) {
            s.addFirst(p);
            p = p.getParent();
        }
        return s;
    }

    @Override
    public Long getId() {
        return id;
    }

    @Override
    public boolean isRoot() {
        return parent == null;
    }

    public boolean isLeaf() {
        return getChildren().isEmpty();
    }

    public Category getParent() {
        return parent;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public long getLeft() {
        return left;
    }

    public void setLeft(long left) {
        this.left = left;
    }

    public long getRight() {
        return right;
    }

    public void setRight(long right) {
        this.right = right;
    }

    /**
     * Traverses the subtree rooted at this node in breadth-first order.
     * The first node visited is this node.
     *
     * @param visitor the node visitor
     */
    public void breadthFirstTraversal(NodeVisitor<Category> visitor) {
        visitor.visit(this);
        getChildren().forEach(category -> category.breadthFirstTraversal(visitor));
    }

    /**
     * Traverses the subtree rooted at this node in depth-first order.
     * The last node visited is this node.
     *
     * @param visitor the node visitor
     */
    public void depthFirstTraversal(NodeVisitor<Category> visitor) {
        getChildren().forEach(category -> category.depthFirstTraversal(visitor));
        visitor.visit(this);
    }

    public List<Category> getChildren() {
        return Collections.unmodifiableList(subCategories);
    }

    //--------------------------------------------------------
    // Categorized product methods
    //--------------------------------------------------------

    public Set<CategorizedProduct> getCategorizedProducts() {
        return Collections.unmodifiableSet(categorizedProducts); // Defensive copy
    }

    public CategorizedProduct addCategorizedProduct(Product product) {
        CategorizedProduct link = new CategorizedProduct(product);
        categorizedProducts.add(link);
        return link;
    }

    public void removeCategorizedProduct(CategorizedProduct categorizedProduct) {
        categorizedProducts.remove(categorizedProduct);
    }

    //--------------------------------------------------------
    // Instance business methods
    //--------------------------------------------------------

    /**
     * Finds a sub-category with the given name.
     *
     * @param name the sub-category name to find
     * @return the category
     * @throws IllegalArgumentException if not found
     */
    public <T extends Category> T getChild(String name, Class<T> categoryClass) {
        for (Category category : subCategories) {
            if (category.getName().equals(name)) {
                return categoryClass.cast(category);
            }
        }
        throw new IllegalArgumentException("No child with name " + name);
    }

    /**
     * Adds a sub-category to this category. If the provided category already
     * is a sub-category, it will be detached from its current parent.
     *
     * @param child the category to add
     * @return the child category
     * @throws IllegalArgumentException if the category is added to itself, or as a child to itself
     */
    public Category add(Category child) {
        Assert.notNull(child, "Can't add a null Category as child");
        Assert.isTrue(child != this, "Can't add a Category to itself");

        for (Category c : child.subCategories) {
            Assert.isTrue(!c.equals(this), "Can't add a Category as child to itself");
        }
        if (child.getParent() != null) {
            child.getParent().subCategories.remove(child);
            if (child.getParent().subCategories.contains(child)) {
                throw new IllegalStateException();
            }
        }

        Assert.isTrue(child.getParent() == null, "Expected " + child
                + " to be an orphan, but its parent is '" + child.getParent() + "'");

        child.parent = this;
        this.subCategories.add(child);

        return child;
    }

    /**
     * Remove a child category from this category.
     *
     * @param child the child
     * @throws IllegalArgumentException if the category was not a child of this node
     */
    public void remove(Category child) {
        Assert.isTrue(subCategories.remove(child), "Can't remove child category");
        child.parent = null;
    }

    /**
     * Compares for equality. Categories are considered equals when
     * their names match.
     *
     * @param o the other category
     * @return true if its equal to this one
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        Category category = (Category) o;

        return name.equals(category.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    @Override
    public int compareTo(Category o) {
        return getName().compareTo(o.getName());
    }

    @Override
    public String toString() {
        return "Category{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", description='" + description + '\'' +
                ", left=" + left +
                ", right=" + right +
                "} " + super.toString();
    }

    /**
     * Prints this category and all its sub-categories as a simple
     * formatted string, illustrating the hierarchy.
     *
     * @return the pretty string
     */
    public String toPrettyString() {
        StringBuffer sb = new StringBuffer();
        debugString(sb, 0);
        return sb.toString();
    }

    private void debugString(StringBuffer sb, int level) {
        if (level > 0) {
            sb.append(spaces(level));
        }
        sb.append(this);
        if (getChildren().size() > 0) {
            sb.append(" {");
        }
        sb.append(LS);
        for (Category subCategory : getChildren()) {
            subCategory.debugString(sb, level + 3);
        }
        if (getChildren().size() > 0) {
            sb.append(spaces(level)).append("}").append(LS);
        }
    }

    private String spaces(int length) {
        return new String(new char[length]).replace('\0', ' ');
    }

    private static final String LS = System.getProperty("line.separator");
}
